import { onCall, HttpsError } from 'firebase-functions/v2/https';
import { logger } from '../utils/logger';
import ImagenService from './imagenService';
import PromptGenerator from './promptGenerator';
import ImageProcessor from './imageProcessor';

// 환경 변수에서 API 키 가져오기
const IMAGEN_API_KEY = process.env.GOOGLE_IMAGEN_API_KEY || '';

// 서비스 인스턴스 생성
const imagenService = new ImagenService(IMAGEN_API_KEY);
const promptGenerator = new PromptGenerator();
const imageProcessor = new ImageProcessor();

/**
 * 색칠놀이 도안 생성 Cloud Function
 */
export const generateColoringPage = onCall(
  {
    region: 'asia-northeast3',
    timeoutSeconds: 540,
    memory: '1GiB',
  },
  async (request) => {
    try {
      const { characterName, characterType, originCountry, ageGroup, difficulty, theme, activity, emotion } = request.data;

      // 입력 검증
      if (!characterName || !characterType || !originCountry || !ageGroup || !difficulty) {
        throw new HttpsError('invalid-argument', 'Missing required parameters');
      }

      logger.info('Starting coloring page generation', {
        characterName,
        characterType,
        originCountry,
        ageGroup,
        difficulty,
        theme,
        activity,
        emotion,
      });

      // 1. 캐릭터 데이터 구성
      const characterData = {
        name: characterName,
        type: characterType,
        originCountry,
        keywords: [], // 실제로는 키워드 수집 서비스에서 가져옴
      };

      // 2. 메타프롬프트 생성
      const promptRequest = {
        character: characterData,
        ageGroup,
        difficulty,
        theme,
        activity,
        emotion,
      };

      const generatedPrompt = promptGenerator.generate(promptRequest);
      
      logger.info('Prompt generated', {
        promptLength: generatedPrompt.mainPrompt.length,
        metadata: generatedPrompt.metadata,
      });

      // 3. AI 이미지 생성
      const imagenResponse = await imagenService.generateColoringPage(
        characterName,
        generatedPrompt.mainPrompt,
        generatedPrompt.negativePrompt,
        ageGroup,
        difficulty,
      );

      logger.info('Image generated by Imagen', {
        numImages: imagenResponse.images.length,
        generationTime: imagenResponse.metadata.generationTime,
      });

      // 4. 윤곽선 추출 및 도안 변환
      const { imageBase64 } = imagenResponse.images[0];
      const outlineResult = await imageProcessor.extractOutline(imageBase64, ageGroup, difficulty);

      logger.info('Outline extraction completed', {
        qualityScore: outlineResult.metadata.qualityScore,
        processingTime: outlineResult.metadata.processingTime,
      });

      // 5. 결과 반환
      return {
        success: true,
        data: {
          coloringPage: {
            imageUrl: outlineResult.outlineImageBase64,
            processedImageUrl: outlineResult.processedImageBase64,
            metadata: {
              character: characterData,
              prompt: generatedPrompt,
              generation: imagenResponse.metadata,
              processing: outlineResult.metadata,
            },
          },
          recommendations: await getRecommendations(characterData, ageGroup),
        },
      };

    } catch (error) {
      logger.error('Failed to generate coloring page', {
        error: error instanceof Error ? error.message : 'Unknown error',
        request: request.data,
      });

      if (error instanceof HttpsError) {
        throw error;
      }

      throw new HttpsError('internal', 'Failed to generate coloring page');
    }
  },
);

/**
 * 일괄 색칠놀이 도안 생성 (스케줄러용)
 */
export const generateBatchColoringPages = onCall(
  {
    region: 'asia-northeast3',
    timeoutSeconds: 540,
    memory: '2GiB',
  },
  async (request) => {
    try {
      const { count = 10, ageGroup = 'child', difficulty = 'easy' } = request.data;

      logger.info('Starting batch coloring page generation', {
        count,
        ageGroup,
        difficulty,
      });

      const results = [];
      const popularCharacters = await getPopularCharacters();

      for (let i = 0; i < count && i < popularCharacters.length; i++) {
        try {
          const character = popularCharacters[i];
          
          const result = await generateColoringPage.run({
            data: {
              characterName: character.name,
              characterType: character.type,
              originCountry: character.originCountry,
              ageGroup,
              difficulty,
              theme: getCurrentTheme(),
              activity: getRandomActivity(),
              emotion: getRandomEmotion(ageGroup),
            },
          });

          results.push({
            success: true,
            character: character.name,
            data: result.data,
          });

          logger.info('Generated coloring page for character', {
            character: character.name,
            index: i + 1,
            total: count,
          });

        } catch (error) {
          logger.error('Failed to generate coloring page for character', {
            character: popularCharacters[i]?.name,
            error: error instanceof Error ? error.message : 'Unknown error',
          });

          results.push({
            success: false,
            character: popularCharacters[i]?.name,
            error: error instanceof Error ? error.message : 'Unknown error',
          });
        }
      }

      const successCount = results.filter(r => r.success).length;
      
      logger.info('Batch generation completed', {
        total: count,
        success: successCount,
        failed: count - successCount,
      });

      return {
        success: true,
        data: {
          total: count,
          success: successCount,
          failed: count - successCount,
          results,
        },
      };

    } catch (error) {
      logger.error('Failed to generate batch coloring pages', {
        error: error instanceof Error ? error.message : 'Unknown error',
      });

      throw new HttpsError('internal', 'Failed to generate batch coloring pages');
    }
  },
);

/**
 * 인기 캐릭터 목록 가져오기
 */
async function getPopularCharacters(): Promise<Array<{
  name: string;
  type: 'anime' | 'cartoon' | 'game' | 'mascot';
  originCountry: 'korea' | 'japan' | 'usa' | 'china' | 'global';
}>> {
  // 실제로는 Firestore에서 인기 캐릭터 데이터를 가져옴
  return [
    { name: 'Pikachu', type: 'anime', originCountry: 'japan' },
    { name: 'SpongeBob', type: 'cartoon', originCountry: 'usa' },
    { name: '뽀로로', type: 'mascot', originCountry: 'korea' },
    { name: 'Naruto', type: 'anime', originCountry: 'japan' },
    { name: 'Mickey Mouse', type: 'cartoon', originCountry: 'usa' },
    { name: 'Steve', type: 'game', originCountry: 'global' },
    { name: 'Elsa', type: 'cartoon', originCountry: 'usa' },
    { name: 'Goku', type: 'anime', originCountry: 'japan' },
    { name: '핑크퐁', type: 'mascot', originCountry: 'korea' },
    { name: 'Mario', type: 'game', originCountry: 'global' },
  ];
}

/**
 * 추천 캐릭터 가져오기
 */
async function getRecommendations(character: any, _ageGroup: string): Promise<any[]> {
  // 실제로는 추천 알고리즘을 사용하여 관련 캐릭터 반환
  return [
    { name: 'Related Character 1', type: character.type, originCountry: character.originCountry },
    { name: 'Related Character 2', type: character.type, originCountry: character.originCountry },
  ];
}

/**
 * 현재 테마 가져오기
 */
function getCurrentTheme(): string {
  const month = new Date().getMonth() + 1;
  const themes = {
    1: 'winter',
    2: 'winter',
    3: 'spring',
    4: 'spring',
    5: 'spring',
    6: 'summer',
    7: 'summer',
    8: 'summer',
    9: 'autumn',
    10: 'autumn',
    11: 'autumn',
    12: 'winter',
  };
  return themes[month] || 'spring';
}

/**
 * 랜덤 액티비티 가져오기
 */
function getRandomActivity(): string {
  const activities = ['playing', 'running', 'jumping', 'sitting', 'dancing', 'sleeping'];
  return activities[Math.floor(Math.random() * activities.length)];
}

/**
 * 연령대별 랜덤 감정 가져오기
 */
function getRandomEmotion(ageGroup: string): string {
  const emotions = {
    child: ['happy', 'excited', 'curious', 'peaceful'],
    teen: ['confident', 'dynamic', 'cool', 'adventurous'],
    adult: ['calm', 'focused', 'creative', 'relaxed'],
  };
  const ageEmotions = emotions[ageGroup] || emotions.child;
  return ageEmotions[Math.floor(Math.random() * ageEmotions.length)];
}